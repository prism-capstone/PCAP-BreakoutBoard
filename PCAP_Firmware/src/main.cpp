#include "pcap_driver.h"
#include "Arduino.h"

#define BAUD_RATE 115200

// Global PCAP driver instance
PCAP_Driver pcap;

// Storage for sensor data from all chips
pcap_data_t chip_data[NUM_PCAP_CHIPS];

// Standard configuration (from your STM32 example)
uint8_t standard_config[PCAP_CONFIG_SIZE] = {
    0x03, 0x11, 0xF8, 0x10, 0x90, 0x0C, 0x3F, 0x0A, 0x00, 0xF4, 0x01, 0x00, 0x27, 0x00, 0x0A, 0x00,
    0x13, 0x78, 0x00, 0x01, 0x00, 0x01, 0x50, 0x30, 0x73, 0x04, 0x50, 0x00, 0x5A, 0x00, 0x82, 0x08,
    0x08, 0x00, 0x47, 0x40, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00
};

uint8_t standard_firmware[PCAP_FW_SIZE] = {
    0x24, 0x05, 0xA0, 0x01, 0x20, 0x55, 0x42, 0x5C, 0x48, 0xB1, 0x07, 0x92, 0x02, 0x20, 0x13, 0x02,
	0x20, 0x93, 0x02, 0xB2, 0x02, 0x78, 0x20, 0x54, 0xB3, 0x06, 0x91, 0x00, 0x7F, 0x20, 0x86, 0x20,
	0x54, 0xB6, 0x03, 0x72, 0x62, 0x20, 0x54, 0xB7, 0x00, 0x00, 0x42, 0x5C, 0xA1, 0x00, 0x49, 0xB0,
	0x00, 0x49, 0x40, 0xAB, 0x5D, 0x92, 0x1C, 0x90, 0x02, 0x7F, 0x20, 0x86, 0x66, 0x67, 0x76, 0x77,
    0x66, 0x7A, 0xCF, 0xCD, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A, 0xDC, 0xE7, 0x41, 0x32, 0xAA,
    0x01, 0x99, 0xFD, 0x7B, 0x01, 0x7A, 0xCF, 0xEB, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A, 0xC1,
    0xE7, 0x41, 0x32, 0x6A, 0xDE, 0x44, 0x7A, 0xCF, 0xEA, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x6A,
    0xDF, 0x44, 0x7A, 0xC4, 0xE7, 0x41, 0x32, 0xAB, 0x05, 0x7A, 0xC1, 0xE1, 0x43, 0xE0, 0x3A, 0x7A,
    0xC0, 0xE1, 0x43, 0xE0, 0x3A, 0x02, 0x7A, 0xCF, 0xE6, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A,
    0xEF, 0x44, 0x02, 0x20, 0x9D, 0x84, 0x01, 0x21, 0x2E, 0x21, 0x74, 0x20, 0x37, 0xC8, 0x7A, 0xE7,
    0x43, 0x49, 0x11, 0x6A, 0xD4, 0x44, 0x7A, 0xC1, 0xD8, 0xE6, 0x43, 0xE9, 0x44, 0x1C, 0x43, 0x13,
    0xAB, 0x63, 0x6A, 0xDE, 0x41, 0xAB, 0x0B, 0x46, 0x46, 0x46, 0x7A, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xE3, 0x41, 0x32, 0x1C, 0x44, 0xE9, 0x13, 0x6A, 0xD4, 0x13, 0x41, 0xAA, 0xDF, 0x7A, 0xC5, 0xE1,
    0x43, 0x49, 0xE0, 0x34, 0x7A, 0xCF, 0xE3, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0xDB, 0xC0, 0x27,
    0xE5, 0x6A, 0xDF, 0x43, 0x7A, 0xC8, 0xE7, 0x41, 0x30, 0xAB, 0x03, 0x86, 0x01, 0x92, 0x37, 0x7A,
    0xC6, 0xE7, 0x41, 0x7A, 0xFA, 0xE7, 0x43, 0xEA, 0x44, 0x7A, 0xC1, 0xE1, 0xE6, 0x43, 0xE9, 0x44,
    0x25, 0xE0, 0x7A, 0xC6, 0xE7, 0x41, 0x7A, 0xFA, 0xE7, 0x43, 0xEA, 0x44, 0x7A, 0xC0, 0xE7, 0x43,
    0xE9, 0x44, 0x25, 0xE0, 0x92, 0x10, 0x7A, 0xE1, 0x44, 0xE2, 0x44, 0xE3, 0x44, 0xE4, 0x44, 0xE5,
    0x44, 0xE6, 0x44, 0xE7, 0x44, 0xE8, 0x44, 0xC1, 0xD8, 0x24, 0x3E, 0x92, 0xFF, 0x02, 0x7A, 0xCF,
    0xD7, 0xE6, 0x43, 0xF1, 0x44, 0x7A, 0xD0, 0xE7, 0x43, 0x2A, 0x2A, 0x32, 0xAB, 0x03, 0x42, 0x5C,
    0x92, 0x03, 0x7A, 0xC0, 0xE1, 0x43, 0xD9, 0x27, 0x90, 0x6A, 0xDF, 0x43, 0x7A, 0xC8, 0xE7, 0x41,
    0x32, 0xAB, 0x03, 0x86, 0x01, 0x92, 0x11, 0x7A, 0xC2, 0x43, 0x7A, 0xE7, 0x44, 0x6A, 0xC6, 0x44,
    0x7A, 0xC3, 0x43, 0x7A, 0xE8, 0x44, 0x6A, 0xC7, 0x44, 0xC1, 0xD4, 0x24, 0x57, 0x7A, 0xC8, 0xE1,
    0x43, 0xE0, 0x3A, 0x02, 0x7A, 0xCF, 0xE7, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A, 0xC7, 0xE1,
    0x41, 0x6A, 0xD4, 0x45, 0x5A, 0x25, 0x36, 0x46, 0x46, 0x46, 0x46, 0x7A, 0xE9, 0x44, 0x7A, 0xC0,
    0xE7, 0x43, 0x55, 0x7A, 0xEA, 0x45, 0x7A, 0xE9, 0x51, 0x1C, 0x43, 0x6A, 0xCA, 0x44, 0x1D, 0x43,
    0x6A, 0xCB, 0x44, 0x7A, 0xC1, 0xCA, 0xE6, 0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x7A, 0xCC,
    0xE0, 0xE6, 0x41, 0x2C, 0x42, 0x7A, 0xC5, 0xE1, 0x43, 0x49, 0xE0, 0x34, 0x7A, 0xC1, 0xCC, 0xE6,
    0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x2C, 0x70, 0x7A, 0xCC, 0x43, 0x7A, 0xCF, 0x44, 0x7A,
    0xCD, 0x43, 0x7A, 0xCE, 0x44, 0x6A, 0xCA, 0x43, 0xC1, 0xCA, 0x7A, 0xE6, 0x41, 0xE9, 0x45, 0x2B,
    0xAE, 0xEE, 0x44, 0x7A, 0xC1, 0xCA, 0xE6, 0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x7A, 0xCC,
    0xEC, 0xE6, 0x41, 0x2C, 0x42, 0x7A, 0xC5, 0xE1, 0x43, 0x49, 0xE0, 0x34, 0x7A, 0xC1, 0xCC, 0xE6,
    0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x2C, 0x70, 0x7A, 0xCC, 0x43, 0x7A, 0xCF, 0x44, 0x7A,
    0xCD, 0x43, 0x7A, 0xCE, 0x44, 0x6A, 0xCB, 0x43, 0xC1, 0xCA, 0x7A, 0xE6, 0x41, 0xE9, 0x45, 0x2B,
    0xAE, 0xED, 0x44, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x35, 0x33, 0x33, 0x07, 0xCD, 0xCC, 0xCC, 0x08, 0x01, 0x00, 0xFE, 0x03, 0x66, 0x66, 0x66, 0x01,
    0x33, 0x33, 0x33, 0x02, 0x01, 0x00, 0xFE, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x11, 0xF8, 0x10, 0x90, 0x0C, 0x3F, 0xFA, 0x00, 0xF4, 0x01, 0x00, 0x03, 0x00, 0xFF, 0x03,
    0x01, 0x08, 0x00, 0x01, 0x00, 0x01, 0x50, 0x30, 0x73, 0x04, 0x50, 0x00, 0x5A, 0x00, 0x82, 0x08,
    0x08, 0x00, 0x47, 0x40, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

void printResults();
void printDiagnostics();

void setup() {
    bool testResult = false;
    Serial.begin(BAUD_RATE);
    delay(2000);  // Wait for serial monitor

    Serial.println("========================================");
    Serial.println("PCAP04 ESP32C3 Firmware Starting...");
    Serial.println("========================================");

    // Print diagnostic information
    printDiagnostics();

    // Initialize the PCAP driver
    pcap.begin();
    delay(1000);

    // Test communication with each chip
    Serial.println("\n--- Testing Communication ---");
    for(int pcap_num = PCAP_CHIP_2; pcap_num <= PCAP_CHIP_8; pcap_num++)
    {
        // Block until we validate a successful communication
        while(testResult == false)
        {
            testResult = pcap.testCommunication((pcap_chip_select_t) pcap_num);
            delay(10);
        }
    }

    // Initialize chips
    Serial.println("\n--- Initializing Chips ---");
    for(int pcap_num = PCAP_CHIP_2; pcap_num <= PCAP_CHIP_8; pcap_num++)
    {
        pcap.initChip((pcap_chip_select_t) pcap_num);
        pcap.writeFirmware((pcap_chip_select_t) pcap_num, standard_firmware, PCAP_FW_SIZE);
        pcap.writeConfig((pcap_chip_select_t) pcap_num, standard_config, PCAP_CONFIG_SIZE);
        pcap.startCDC((pcap_chip_select_t) pcap_num);
    }
}

void loop() {
    static unsigned long last_measurement = 0;
    unsigned long current_time = millis();
    
    // Take measurement every 10ms (100Hz)
    if (current_time - last_measurement >= 10) {
        last_measurement = current_time;
        
        // Read results from each chip
        for(int pcap_num = PCAP_CHIP_2; pcap_num <= PCAP_CHIP_8; pcap_num++)
        {
            pcap.readPCAP((pcap_chip_select_t) pcap_num, &chip_data[pcap_num]);
        }
        
        // Print results
        printResults();
    }
}

void printResults() {
    static int print_counter = 0;
    
    // Only print every 50 measurements (every 500ms at 100Hz)
    print_counter++;
    if (print_counter < 50) {
        return;
    }
    print_counter = 0;
    
    // Print header
    Serial.println("\n--- PCAP Measurements (100Hz sampling) ---");
    Serial.println("Chip | S0       | S1       | S2       | S3       | S4       | S5");
    Serial.println("-----|----------|----------|----------|----------|----------|----------");
    
    // Print data for each chip
    for (int chip = PCAP_CHIP_2; chip <= PCAP_CHIP_8; chip++) {
        Serial.print("  ");
        Serial.print(chip + 1);
        Serial.print("  | ");
        
        for (int sensor = 0; sensor < NUM_SENSORS_PER_CHIP; sensor++) {
            uint32_t value = chip_data[chip].raw[sensor];
            
            // Print value with padding
            if (value < 10000000) Serial.print(" ");
            if (value < 1000000) Serial.print(" ");
            if (value < 100000) Serial.print(" ");
            if (value < 10000) Serial.print(" ");
            if (value < 1000) Serial.print(" ");
            if (value < 100) Serial.print(" ");
            if (value < 10) Serial.print(" ");
            
            Serial.print(value);
            Serial.print(" | ");
        }
        Serial.println();
    }
}

void printDiagnostics() {
    Serial.println("\n--- System Diagnostics ---");
    Serial.print("ESP32 Chip Model: ");
    Serial.println(ESP.getChipModel());
    Serial.print("Chip Revision: ");
    Serial.println(ESP.getChipRevision());
    Serial.print("CPU Frequency: ");
    Serial.print(ESP.getCpuFreqMHz());
    Serial.println(" MHz");
    Serial.print("Free Heap: ");
    Serial.print(ESP.getFreeHeap());
    Serial.println(" bytes");

    Serial.println("\n--- Pin Configuration ---");
    Serial.print("MUX_S0_PIN (D3): GPIO ");
    Serial.println(D3);
    Serial.print("MUX_S1_PIN (D2): GPIO ");
    Serial.println(D2);
    Serial.print("MUX_S2_PIN (D1): GPIO ");
    Serial.println(D1);
    Serial.print("MUX_S3_PIN (D0): GPIO ");
    Serial.println(D0);
    Serial.println("CS Control: Multiplexer (COMMON_I/O = GND, pull-ups on outputs)");

    Serial.println("\n--- SPI Pin Configuration ---");
    Serial.println("Hardware SPI (VSPI on ESP32C3):");
    Serial.println("  Expected MOSI: GPIO 10");
    Serial.println("  Expected MISO: GPIO 9");
    Serial.println("  Expected SCK:  GPIO 8");
    Serial.print("  Actual MOSI: GPIO ");
    Serial.println(MOSI);
    Serial.print("  Actual MISO: GPIO ");
    Serial.println(MISO);
    Serial.print("  Actual SCK:  GPIO ");
    Serial.println(SCK);

    Serial.println("\n--- Configuration ---");
    Serial.print("Number of PCAP chips: ");
    Serial.println(NUM_PCAP_CHIPS);
    Serial.print("Sensors per chip: ");
    Serial.println(NUM_SENSORS_PER_CHIP);
    Serial.print("Config size: ");
    Serial.print(PCAP_CONFIG_SIZE);
    Serial.println(" bytes");
    Serial.print("Firmware size: ");
    Serial.print(PCAP_FW_SIZE);
    Serial.println(" bytes");
    Serial.println("========================================");
}