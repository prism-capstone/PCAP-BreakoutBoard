/**
 * @file main.c
 * @brief Main application for PCAP04 capacitive sensor system (ESP-IDF)
 *
 * This firmware reads capacitive sensor data from multiple PCAP04 chips,
 * applies neural network-based hysteresis compensation, and transmits
 * the data via BLE to connected mobile applications.
 */

#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "esp_system.h"
#include "esp_chip_info.h"
#include "esp_flash.h"
#include "esp_task_wdt.h"

#include "pcap_driver.h"
#include "ble_manager.h"
#include "nn_inference.h"

static const char* TAG = "MAIN";

// Storage for sensor data from all chips
static pcap_data_t chip_data[NUM_PCAP_CHIPS];

// Standard configuration (from original firmware)
static const uint8_t standard_config[PCAP_CONFIG_SIZE] = {
    0x03, 0x11, 0xF8, 0x10, 0x90, 0x0C, 0x3F, 0x0A, 0x00, 0xF4, 0x01, 0x00, 0x27, 0x00, 0x0A, 0x00,
    0x13, 0x78, 0x00, 0x01, 0x00, 0x01, 0x50, 0x30, 0x73, 0x04, 0x50, 0x00, 0x5A, 0x00, 0x82, 0x08,
    0x08, 0x00, 0x47, 0x40, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00
};

// Standard firmware (from original firmware)
static const uint8_t standard_firmware[PCAP_FW_SIZE] = {
    0x24, 0x05, 0xA0, 0x01, 0x20, 0x55, 0x42, 0x5C, 0x48, 0xB1, 0x07, 0x92, 0x02, 0x20, 0x13, 0x02,
    0x20, 0x93, 0x02, 0xB2, 0x02, 0x78, 0x20, 0x54, 0xB3, 0x06, 0x91, 0x00, 0x7F, 0x20, 0x86, 0x20,
    0x54, 0xB6, 0x03, 0x72, 0x62, 0x20, 0x54, 0xB7, 0x00, 0x00, 0x42, 0x5C, 0xA1, 0x00, 0x49, 0xB0,
    0x00, 0x49, 0x40, 0xAB, 0x5D, 0x92, 0x1C, 0x90, 0x02, 0x7F, 0x20, 0x86, 0x66, 0x67, 0x76, 0x77,
    0x66, 0x7A, 0xCF, 0xCD, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A, 0xDC, 0xE7, 0x41, 0x32, 0xAA,
    0x01, 0x99, 0xFD, 0x7B, 0x01, 0x7A, 0xCF, 0xEB, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A, 0xC1,
    0xE7, 0x41, 0x32, 0x6A, 0xDE, 0x44, 0x7A, 0xCF, 0xEA, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x6A,
    0xDF, 0x44, 0x7A, 0xC4, 0xE7, 0x41, 0x32, 0xAB, 0x05, 0x7A, 0xC1, 0xE1, 0x43, 0xE0, 0x3A, 0x7A,
    0xC0, 0xE1, 0x43, 0xE0, 0x3A, 0x02, 0x7A, 0xCF, 0xE6, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A,
    0xEF, 0x44, 0x02, 0x20, 0x9D, 0x84, 0x01, 0x21, 0x2E, 0x21, 0x74, 0x20, 0x37, 0xC8, 0x7A, 0xE7,
    0x43, 0x49, 0x11, 0x6A, 0xD4, 0x44, 0x7A, 0xC1, 0xD8, 0xE6, 0x43, 0xE9, 0x44, 0x1C, 0x43, 0x13,
    0xAB, 0x63, 0x6A, 0xDE, 0x41, 0xAB, 0x0B, 0x46, 0x46, 0x46, 0x7A, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xE3, 0x41, 0x32, 0x1C, 0x44, 0xE9, 0x13, 0x6A, 0xD4, 0x13, 0x41, 0xAA, 0xDF, 0x7A, 0xC5, 0xE1,
    0x43, 0x49, 0xE0, 0x34, 0x7A, 0xCF, 0xE3, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0xDB, 0xC0, 0x27,
    0xE5, 0x6A, 0xDF, 0x43, 0x7A, 0xC8, 0xE7, 0x41, 0x30, 0xAB, 0x03, 0x86, 0x01, 0x92, 0x37, 0x7A,
    0xC6, 0xE7, 0x41, 0x7A, 0xFA, 0xE7, 0x43, 0xEA, 0x44, 0x7A, 0xC1, 0xE1, 0xE6, 0x43, 0xE9, 0x44,
    0x25, 0xE0, 0x7A, 0xC6, 0xE7, 0x41, 0x7A, 0xFA, 0xE7, 0x43, 0xEA, 0x44, 0x7A, 0xC0, 0xE7, 0x43,
    0xE9, 0x44, 0x25, 0xE0, 0x92, 0x10, 0x7A, 0xE1, 0x44, 0xE2, 0x44, 0xE3, 0x44, 0xE4, 0x44, 0xE5,
    0x44, 0xE6, 0x44, 0xE7, 0x44, 0xE8, 0x44, 0xC1, 0xD8, 0x24, 0x3E, 0x92, 0xFF, 0x02, 0x7A, 0xCF,
    0xD7, 0xE6, 0x43, 0xF1, 0x44, 0x7A, 0xD0, 0xE7, 0x43, 0x2A, 0x2A, 0x32, 0xAB, 0x03, 0x42, 0x5C,
    0x92, 0x03, 0x7A, 0xC0, 0xE1, 0x43, 0xD9, 0x27, 0x90, 0x6A, 0xDF, 0x43, 0x7A, 0xC8, 0xE7, 0x41,
    0x32, 0xAB, 0x03, 0x86, 0x01, 0x92, 0x11, 0x7A, 0xC2, 0x43, 0x7A, 0xE7, 0x44, 0x6A, 0xC6, 0x44,
    0x7A, 0xC3, 0x43, 0x7A, 0xE8, 0x44, 0x6A, 0xC7, 0x44, 0xC1, 0xD4, 0x24, 0x57, 0x7A, 0xC8, 0xE1,
    0x43, 0xE0, 0x3A, 0x02, 0x7A, 0xCF, 0xE7, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A, 0xC7, 0xE1,
    0x41, 0x6A, 0xD4, 0x45, 0x5A, 0x25, 0x36, 0x46, 0x46, 0x46, 0x46, 0x7A, 0xE9, 0x44, 0x7A, 0xC0,
    0xE7, 0x43, 0x55, 0x7A, 0xEA, 0x45, 0x7A, 0xE9, 0x51, 0x1C, 0x43, 0x6A, 0xCA, 0x44, 0x1D, 0x43,
    0x6A, 0xCB, 0x44, 0x7A, 0xC1, 0xCA, 0xE6, 0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x7A, 0xCC,
    0xE0, 0xE6, 0x41, 0x2C, 0x42, 0x7A, 0xC5, 0xE1, 0x43, 0x49, 0xE0, 0x34, 0x7A, 0xC1, 0xCC, 0xE6,
    0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x2C, 0x70, 0x7A, 0xCC, 0x43, 0x7A, 0xCF, 0x44, 0x7A,
    0xCD, 0x43, 0x7A, 0xCE, 0x44, 0x6A, 0xCA, 0x43, 0xC1, 0xCA, 0x7A, 0xE6, 0x41, 0xE9, 0x45, 0x2B,
    0xAE, 0xEE, 0x44, 0x7A, 0xC1, 0xCA, 0xE6, 0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x7A, 0xCC,
    0xEC, 0xE6, 0x41, 0x2C, 0x42, 0x7A, 0xC5, 0xE1, 0x43, 0x49, 0xE0, 0x34, 0x7A, 0xC1, 0xCC, 0xE6,
    0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x2C, 0x70, 0x7A, 0xCC, 0x43, 0x7A, 0xCF, 0x44, 0x7A,
    0xCD, 0x43, 0x7A, 0xCE, 0x44, 0x6A, 0xCB, 0x43, 0xC1, 0xCA, 0x7A, 0xE6, 0x41, 0xE9, 0x45, 0x2B,
    0xAE, 0xED, 0x44, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Padding to 1024 bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x35, 0x33, 0x33, 0x07, 0xCD, 0xCC, 0xCC, 0x08, 0x01, 0x00, 0xFE, 0x03, 0x66, 0x66, 0x66, 0x01,
    0x33, 0x33, 0x33, 0x02, 0x01, 0x00, 0xFE, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x11, 0xF8, 0x10, 0x90, 0x0C, 0x3F, 0xFA, 0x00, 0xF4, 0x01, 0x00, 0x03, 0x00, 0xFF, 0x03,
    0x01, 0x08, 0x00, 0x01, 0x00, 0x01, 0x50, 0x30, 0x73, 0x04, 0x50, 0x00, 0x5A, 0x00, 0x82, 0x08,
    0x08, 0x00, 0x47, 0x40, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Function declarations
static void print_diagnostics(void);
static void print_results(void);
static void sensor_task(void *pvParameters);

static void print_diagnostics(void)
{
    esp_chip_info_t chip_info;
    uint32_t flash_size;

    esp_chip_info(&chip_info);

    ESP_LOGI(TAG, "========================================");
    ESP_LOGI(TAG, "--- System Diagnostics ---");
    ESP_LOGI(TAG, "Chip: %s with %d CPU core(s)",
             CONFIG_IDF_TARGET, chip_info.cores);
    ESP_LOGI(TAG, "Silicon revision: %d", chip_info.revision);

    if (esp_flash_get_size(NULL, &flash_size) == ESP_OK) {
        ESP_LOGI(TAG, "Flash size: %lu MB", flash_size / (1024 * 1024));
    }

    ESP_LOGI(TAG, "Free heap: %lu bytes", esp_get_free_heap_size());
    ESP_LOGI(TAG, "Minimum free heap: %lu bytes", esp_get_minimum_free_heap_size());

    ESP_LOGI(TAG, "--- Pin Configuration ---");
    ESP_LOGI(TAG, "MUX_S0_PIN: GPIO %d", MUX_S0_PIN);
    ESP_LOGI(TAG, "MUX_S1_PIN: GPIO %d", MUX_S1_PIN);
    ESP_LOGI(TAG, "MUX_S2_PIN: GPIO %d", MUX_S2_PIN);
    ESP_LOGI(TAG, "MUX_S3_PIN: GPIO %d", MUX_S3_PIN);
    ESP_LOGI(TAG, "SPI MOSI: GPIO %d", PCAP_SPI_MOSI_PIN);
    ESP_LOGI(TAG, "SPI MISO: GPIO %d", PCAP_SPI_MISO_PIN);
    ESP_LOGI(TAG, "SPI SCLK: GPIO %d", PCAP_SPI_SCLK_PIN);

    ESP_LOGI(TAG, "--- Configuration ---");
    ESP_LOGI(TAG, "Number of PCAP chips: %d", NUM_PCAP_CHIPS);
    ESP_LOGI(TAG, "Sensors per chip: %d", NUM_SENSORS_PER_CHIP);
    ESP_LOGI(TAG, "NN inference ready: %s", nn_is_ready() ? "YES" : "NO");
    ESP_LOGI(TAG, "========================================");
}

static void print_results(void)
{
    static int print_counter = 0;

    // Only print every 50 measurements (every 500ms at 100Hz)
    print_counter++;
    if (print_counter < 50) {
        return;
    }
    print_counter = 0;

    // Print header
    printf("\n--- PCAP Measurements (100Hz sampling) ---\n");
    printf("Chip | S0       | S1       | S2       | S3       | S4       | S5\n");
    printf("-----|----------|----------|----------|----------|----------|----------\n");

    // Print data for each chip
    for (int chip = PCAP_CHIP_2; chip <= PCAP_CHIP_8; chip++) {
        printf("  %d  | ", chip + 1);

        for (int sensor = 0; sensor < NUM_SENSORS_PER_CHIP; sensor++) {
            // Use NN-compensated value if available, otherwise raw-offset
            uint32_t value;
            if (nn_is_ready()) {
                value = chip_data[chip].final_val[sensor];
            }
            else {
                value = chip_data[chip].raw[sensor] - chip_data[chip].offset[sensor];
            }

            printf("%ld | ", value);
        }
        printf("\n");
    }

    // Print NN stats if available
    if (nn_is_ready()) {
        printf("NN inference time: %lu us (avg)\n", nn_get_inference_time_us());
    }
}

static void sensor_task(void *pvParameters)
{
    TickType_t last_measurement = 0;
    TickType_t last_ble_update = 0;
    const TickType_t measurement_period = pdMS_TO_TICKS(10);  // 100Hz
    const TickType_t ble_update_period = pdMS_TO_TICKS(50);   // 20Hz

    ESP_LOGI(TAG, "Sensor task started");

    while (1) {
        TickType_t current_time = xTaskGetTickCount();

        // Take measurement every 10ms (100Hz)
        if ((current_time - last_measurement) >= measurement_period) {
            last_measurement = current_time;

            // Read results from each chip
            for (int pcap_num = PCAP_CHIP_2; pcap_num <= PCAP_CHIP_8; pcap_num++) {
                pcap_read_data((pcap_chip_select_t)pcap_num, &chip_data[pcap_num]);

                // Apply NN-based hysteresis compensation
                if (nn_is_ready()) {
                    nn_compensate_chip(&chip_data[pcap_num]);
                }
            }

            // Print results to serial
            print_results();
        }

        // Send BLE updates every 50ms (20Hz) if connected
        if (ble_is_connected() && (current_time - last_ble_update) >= ble_update_period) {
            last_ble_update = current_time;

            // Send data from all active chips
            for (int pcap_num = PCAP_CHIP_2; pcap_num <= PCAP_CHIP_8; pcap_num++) {
                ble_send_chip_data(pcap_num, &chip_data[pcap_num]);
            }
        }

        // Delay to allow other tasks to run
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

void app_main(void)
{
    bool test_result = false;

    ESP_LOGI(TAG, "========================================");
    ESP_LOGI(TAG, "PCAP04 ESP32C3 Firmware Starting...");
    ESP_LOGI(TAG, "========================================");

    // Initialize PCAP driver (includes SPI and MUX init)
    pcap_driver_init();
    vTaskDelay(pdMS_TO_TICKS(1000));

    // Test communication with each chip
    ESP_LOGI(TAG, "--- Testing Communication ---");
    for (int pcap_num = PCAP_CHIP_2; pcap_num <= PCAP_CHIP_8; pcap_num++) {
        // Block until we validate a successful communication
        test_result = false;
        while (!test_result) {
            test_result = pcap_test_communication((pcap_chip_select_t)pcap_num);
            vTaskDelay(pdMS_TO_TICKS(10));
        }
    }

    // Initialize chips
    ESP_LOGI(TAG, "--- Initializing Chips ---");
    for (int pcap_num = PCAP_CHIP_2; pcap_num <= PCAP_CHIP_8; pcap_num++) {
        pcap_init_chip((pcap_chip_select_t)pcap_num);
        pcap_write_firmware((pcap_chip_select_t)pcap_num, standard_firmware, PCAP_FW_SIZE);
        pcap_write_config((pcap_chip_select_t)pcap_num, standard_config, PCAP_CONFIG_SIZE);
        pcap_start_cdc((pcap_chip_select_t)pcap_num);
    }

    // Wait for first measurement to complete
    ESP_LOGI(TAG, "--- Waiting for measurements to stabilize ---");
    vTaskDelay(pdMS_TO_TICKS(20));

    // Calibrate all chips
    ESP_LOGI(TAG, "--- Calibrating Sensors ---");
    for (int pcap_num = PCAP_CHIP_2; pcap_num <= PCAP_CHIP_8; pcap_num++) {
        pcap_calibrate((pcap_chip_select_t)pcap_num, &chip_data[pcap_num], 16);
    }

    // Initialize BLE
    ESP_LOGI(TAG, "--- Initializing BLE ---");
    ble_manager_init();

    // // Initialize Neural Network (optional - will gracefully fail if no model)
    // ESP_LOGI(TAG, "--- Initializing Neural Network ---");
    // if (nn_init()) {
    //     ESP_LOGI(TAG, "Neural network initialized successfully");
    // } else {
    //     ESP_LOGW(TAG, "Neural network initialization failed - using raw values");
    // }

    // Print diagnostics
    print_diagnostics();

    ESP_LOGI(TAG, "Setup complete! Starting measurements...");

    // Create sensor task
    xTaskCreate(sensor_task, "sensor_task", 4096, NULL, 5, NULL);

    // Main task can now idle
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
