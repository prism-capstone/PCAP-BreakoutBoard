/**
 * @file main.c
 * @brief Main application for PCAP04 capacitive sensor system (ESP-IDF)
 *
 * This firmware reads capacitive sensor data from multiple PCAP04 chips,
 * applies neural network-based hysteresis compensation, and transmits
 * the data via BLE to connected mobile applications.
 */

#include <math.h>
#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "esp_log.h"
#include "esp_system.h"
#include "esp_chip_info.h"
#include "esp_flash.h"
#include "esp_task_wdt.h"

#include "pcap_driver.h"
#include "ble_manager.h"
#include "battery_manager.h"
#include "nn_inference.h"

// Add battery header if available
// #include "battery.h"  // Uncomment when battery.h exists

static const char* TAG = "MAIN";

// Set to 1 to enable BLE test mode (skips PCAP, sends dummy data)
#define BLE_TEST_MODE 0

// Storage for sensor data from all chips
static pcap_data_t chip_data[NUM_PCAP_CHIPS];

// Battery monitoring configuration
#define BATTERY_UPDATE_INTERVAL_MS 5000  // Update every 5 seconds

// External battery function declaration
extern uint8_t battery_get_percentage(void);

#if BLE_TEST_MODE == 0
// Standard configuration (from original firmware)
static const uint8_t standard_config[PCAP_CONFIG_SIZE] = {
    0x03, 0x11, 0xF8, 0x10, 0x90, 0x0C, 0x3F, 0x0A, 0x00, 0xF4, 0x01, 0x00, 0x27, 0x00, 0x0A, 0x00,
    0x13, 0x78, 0x00, 0x01, 0x00, 0x01, 0x50, 0x30, 0x73, 0x04, 0x50, 0x00, 0x5A, 0x00, 0x82, 0x08,
    0x08, 0x00, 0x47, 0x40, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00
};

// Standard firmware (from original firmware)
static const uint8_t standard_firmware[PCAP_FW_SIZE] = {
    0x24, 0x05, 0xA0, 0x01, 0x20, 0x55, 0x42, 0x5C, 0x48, 0xB1, 0x07, 0x92, 0x02, 0x20, 0x13, 0x02,
    0x20, 0x93, 0x02, 0xB2, 0x02, 0x78, 0x20, 0x54, 0xB3, 0x06, 0x91, 0x00, 0x7F, 0x20, 0x86, 0x20,
    0x54, 0xB6, 0x03, 0x72, 0x62, 0x20, 0x54, 0xB7, 0x00, 0x00, 0x42, 0x5C, 0xA1, 0x00, 0x49, 0xB0,
    0x00, 0x49, 0x40, 0xAB, 0x5D, 0x92, 0x1C, 0x90, 0x02, 0x7F, 0x20, 0x86, 0x66, 0x67, 0x76, 0x77,
    0x66, 0x7A, 0xCF, 0xCD, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A, 0xDC, 0xE7, 0x41, 0x32, 0xAA,
    0x01, 0x99, 0xFD, 0x7B, 0x01, 0x7A, 0xCF, 0xEB, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A, 0xC1,
    0xE7, 0x41, 0x32, 0x6A, 0xDE, 0x44, 0x7A, 0xCF, 0xEA, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x6A,
    0xDF, 0x44, 0x7A, 0xC4, 0xE7, 0x41, 0x32, 0xAB, 0x05, 0x7A, 0xC1, 0xE1, 0x43, 0xE0, 0x3A, 0x7A,
    0xC0, 0xE1, 0x43, 0xE0, 0x3A, 0x02, 0x7A, 0xCF, 0xE6, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A,
    0xEF, 0x44, 0x02, 0x20, 0x9D, 0x84, 0x01, 0x21, 0x2E, 0x21, 0x74, 0x20, 0x37, 0xC8, 0x7A, 0xE7,
    0x43, 0x49, 0x11, 0x6A, 0xD4, 0x44, 0x7A, 0xC1, 0xD8, 0xE6, 0x43, 0xE9, 0x44, 0x1C, 0x43, 0x13,
    0xAB, 0x63, 0x6A, 0xDE, 0x41, 0xAB, 0x0B, 0x46, 0x46, 0x46, 0x7A, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xE3, 0x41, 0x32, 0x1C, 0x44, 0xE9, 0x13, 0x6A, 0xD4, 0x13, 0x41, 0xAA, 0xDF, 0x7A, 0xC5, 0xE1,
    0x43, 0x49, 0xE0, 0x34, 0x7A, 0xCF, 0xE3, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0xDB, 0xC0, 0x27,
    0xE5, 0x6A, 0xDF, 0x43, 0x7A, 0xC8, 0xE7, 0x41, 0x30, 0xAB, 0x03, 0x86, 0x01, 0x92, 0x37, 0x7A,
    0xC6, 0xE7, 0x41, 0x7A, 0xFA, 0xE7, 0x43, 0xEA, 0x44, 0x7A, 0xC1, 0xE1, 0xE6, 0x43, 0xE9, 0x44,
    0x25, 0xE0, 0x7A, 0xC6, 0xE7, 0x41, 0x7A, 0xFA, 0xE7, 0x43, 0xEA, 0x44, 0x7A, 0xC0, 0xE7, 0x43,
    0xE9, 0x44, 0x25, 0xE0, 0x92, 0x10, 0x7A, 0xE1, 0x44, 0xE2, 0x44, 0xE3, 0x44, 0xE4, 0x44, 0xE5,
    0x44, 0xE6, 0x44, 0xE7, 0x44, 0xE8, 0x44, 0xC1, 0xD8, 0x24, 0x3E, 0x92, 0xFF, 0x02, 0x7A, 0xCF,
    0xD7, 0xE6, 0x43, 0xF1, 0x44, 0x7A, 0xD0, 0xE7, 0x43, 0x2A, 0x2A, 0x32, 0xAB, 0x03, 0x42, 0x5C,
    0x92, 0x03, 0x7A, 0xC0, 0xE1, 0x43, 0xD9, 0x27, 0x90, 0x6A, 0xDF, 0x43, 0x7A, 0xC8, 0xE7, 0x41,
    0x32, 0xAB, 0x03, 0x86, 0x01, 0x92, 0x11, 0x7A, 0xC2, 0x43, 0x7A, 0xE7, 0x44, 0x6A, 0xC6, 0x44,
    0x7A, 0xC3, 0x43, 0x7A, 0xE8, 0x44, 0x6A, 0xC7, 0x44, 0xC1, 0xD4, 0x24, 0x57, 0x7A, 0xC8, 0xE1,
    0x43, 0xE0, 0x3A, 0x02, 0x7A, 0xCF, 0xE7, 0xE6, 0x43, 0xF1, 0x44, 0x29, 0xE0, 0x7A, 0xC7, 0xE1,
    0x41, 0x6A, 0xD4, 0x45, 0x5A, 0x25, 0x36, 0x46, 0x46, 0x46, 0x46, 0x7A, 0xE9, 0x44, 0x7A, 0xC0,
    0xE7, 0x43, 0x55, 0x7A, 0xEA, 0x45, 0x7A, 0xE9, 0x51, 0x1C, 0x43, 0x6A, 0xCA, 0x44, 0x1D, 0x43,
    0x6A, 0xCB, 0x44, 0x7A, 0xC1, 0xCA, 0xE6, 0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x7A, 0xCC,
    0xE0, 0xE6, 0x41, 0x2C, 0x42, 0x7A, 0xC5, 0xE1, 0x43, 0x49, 0xE0, 0x34, 0x7A, 0xC1, 0xCC, 0xE6,
    0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x2C, 0x70, 0x7A, 0xCC, 0x43, 0x7A, 0xCF, 0x44, 0x7A,
    0xCD, 0x43, 0x7A, 0xCE, 0x44, 0x6A, 0xCA, 0x43, 0xC1, 0xCA, 0x7A, 0xE6, 0x41, 0xE9, 0x45, 0x2B,
    0xAE, 0xEE, 0x44, 0x7A, 0xC1, 0xCA, 0xE6, 0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x7A, 0xCC,
    0xEC, 0xE6, 0x41, 0x2C, 0x42, 0x7A, 0xC5, 0xE1, 0x43, 0x49, 0xE0, 0x34, 0x7A, 0xC1, 0xCC, 0xE6,
    0x43, 0xE9, 0x44, 0x7A, 0xC1, 0xE1, 0x43, 0x2C, 0x70, 0x7A, 0xCC, 0x43, 0x7A, 0xCF, 0x44, 0x7A,
    0xCD, 0x43, 0x7A, 0xCE, 0x44, 0x6A, 0xCB, 0x43, 0xC1, 0xCA, 0x7A, 0xE6, 0x41, 0xE9, 0x45, 0x2B,
    0xAE, 0xED, 0x44, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Padding to 1024 bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x35, 0x33, 0x33, 0x07, 0xCD, 0xCC, 0xCC, 0x08, 0x01, 0x00, 0xFE, 0x03, 0x66, 0x66, 0x66, 0x01,
    0x33, 0x33, 0x33, 0x02, 0x01, 0x00, 0xFE, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x11, 0xF8, 0x10, 0x90, 0x0C, 0x3F, 0xFA, 0x00, 0xF4, 0x01, 0x00, 0x03, 0x00, 0xFF, 0x03,
    0x01, 0x08, 0x00, 0x01, 0x00, 0x01, 0x50, 0x30, 0x73, 0x04, 0x50, 0x00, 0x5A, 0x00, 0x82, 0x08,
    0x08, 0x00, 0x47, 0x40, 0x00, 0x00, 0x00, 0x71, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
#endif

// Function declarations
static void print_diagnostics(void);
static void print_results(void);
static void sensor_task(void *pvParameters);
static void battery_task(void *pvParameters);

#if BLE_TEST_MODE
/**
 * @brief Generate dummy sensor data for BLE testing
 * 
 * Creates varying data patterns on 4 selected sensors:
 * - Chip 2, Sensor 0: Increasing (0.0 to 100.0)
 * - Chip 4, Sensor 2: Decreasing (100.0 to 0.0)
 * - Chip 6, Sensor 4: Sine wave (0.0 to 100.0)
 * - Chip 8, Sensor 5: Random values (0.0 to 100.0)
 */
static void generate_dummy_data(void)
{
    static float counter = 0.0f;
    
    // Reset all data to zero first
    for (int chip = PCAP_CHIP_2; chip <= PCAP_CHIP_8; chip++) {
        for (int sensor = 0; sensor < NUM_SENSORS_PER_CHIP; sensor++) {
            chip_data[chip].final_val[sensor] = 0.0f;
            chip_data[chip].raw[sensor] = 0;
            chip_data[chip].offset[sensor] = 0;
        }
    }
    
    // Test sensor 1: Chip 2, Sensor 0 - Increasing value
    chip_data[PCAP_CHIP_2].final_val[0] = fmodf(counter, 100.0f);
    chip_data[PCAP_CHIP_2].raw[0] = (uint32_t)chip_data[PCAP_CHIP_2].final_val[0];
    
    // Test sensor 2: Chip 4, Sensor 2 - Decreasing value
    chip_data[PCAP_CHIP_4].final_val[2] = 100.0f - fmodf(counter, 100.0f);
    chip_data[PCAP_CHIP_4].raw[2] = (uint32_t)chip_data[PCAP_CHIP_4].final_val[2];
    
    // Test sensor 3: Chip 6, Sensor 4 - Sine wave
    float sine_val = (sinf(counter * 0.1f) + 1.0f) * 50.0f;  // 0-100 range
    chip_data[PCAP_CHIP_6].final_val[4] = sine_val;
    chip_data[PCAP_CHIP_6].raw[4] = (uint32_t)sine_val;
    
    // Test sensor 4: Chip 8, Sensor 5 - Random values
    float random_val = (float)(esp_random() % 10000) / 100.0f;  // 0-100 range
    chip_data[PCAP_CHIP_8].final_val[5] = random_val;
    chip_data[PCAP_CHIP_8].raw[5] = (uint32_t)random_val;
    
    // Increment counter for next iteration
    counter += 1.0f;
    if (counter >= 100.0f) {
        counter = 0.0f;
    }
}
#endif

static void print_diagnostics(void)
{
    esp_chip_info_t chip_info;
    uint32_t flash_size;

    esp_chip_info(&chip_info);

    ESP_LOGI(TAG, "========================================");
    ESP_LOGI(TAG, "--- System Diagnostics ---");
    ESP_LOGI(TAG, "Chip: %s with %d CPU core(s)",
             CONFIG_IDF_TARGET, chip_info.cores);
    ESP_LOGI(TAG, "Silicon revision: %d", chip_info.revision);

    if (esp_flash_get_size(NULL, &flash_size) == ESP_OK) {
        ESP_LOGI(TAG, "Flash size: %lu MB", flash_size / (1024 * 1024));
    }

    ESP_LOGI(TAG, "Free heap: %lu bytes", esp_get_free_heap_size());
    ESP_LOGI(TAG, "Minimum free heap: %lu bytes", esp_get_minimum_free_heap_size());

    ESP_LOGI(TAG, "--- Pin Configuration ---");
    ESP_LOGI(TAG, "MUX_S0_PIN: GPIO %d", MUX_S0_PIN);
    ESP_LOGI(TAG, "MUX_S1_PIN: GPIO %d", MUX_S1_PIN);
    ESP_LOGI(TAG, "MUX_S2_PIN: GPIO %d", MUX_S2_PIN);
    ESP_LOGI(TAG, "MUX_S3_PIN: GPIO %d", MUX_S3_PIN);
    ESP_LOGI(TAG, "SPI MOSI: GPIO %d", PCAP_SPI_MOSI_PIN);
    ESP_LOGI(TAG, "SPI MISO: GPIO %d", PCAP_SPI_MISO_PIN);
    ESP_LOGI(TAG, "SPI SCLK: GPIO %d", PCAP_SPI_SCLK_PIN);

    ESP_LOGI(TAG, "--- Configuration ---");
    ESP_LOGI(TAG, "Number of PCAP chips: %d", NUM_PCAP_CHIPS);
    ESP_LOGI(TAG, "Sensors per chip: %d", NUM_SENSORS_PER_CHIP);
    ESP_LOGI(TAG, "NN inference ready: %s", nn_is_ready() ? "YES" : "NO");
    ESP_LOGI(TAG, "========================================");
}

static void print_results(void)
{
    static int print_counter = 0;

    // Only print every 50 measurements (every 500ms at 100Hz)
    print_counter++;
    if (print_counter < 50) {
        return;
    }
    print_counter = 0;

    // Print header
    printf("\n--- PCAP Measurements (100Hz sampling) ---\n");
    printf("Chip | S0       | S1       | S2       | S3       | S4       | S5\n");
    printf("-----|----------|----------|----------|----------|----------|----------\n");

    // Print data for each chip
    for (int chip = PCAP_CHIP_2; chip <= PCAP_CHIP_8; chip++) {
        printf("  %d  | ", chip + 1);

        for (int sensor = 0; sensor < NUM_SENSORS_PER_CHIP; sensor++) {
            // Use NN-compensated value if available, otherwise raw-offset
            if (!nn_is_ready()) {
                chip_data[chip].final_val[sensor] = (float)(chip_data[chip].raw[sensor] - chip_data[chip].offset[sensor]);            
            }
            float value = chip_data[chip].final_val[sensor];
            printf("%.2f | ", value);
        }
        printf("\n");
    }

    // Print NN stats if available
    if (nn_is_ready()) {
        printf("NN inference time: %lu us (avg)\n", nn_get_inference_time_us());
    }
}

/**
 * @brief Battery monitoring task
 * 
 * Periodically reads battery level and sends it over BLE.
 * Runs independently from sensor task to avoid coupling.
 */
static void battery_task(void *pvParameters)
{
    ESP_LOGI(TAG, "Battery monitoring task started");
    
    TickType_t last_update = 0;
    const TickType_t update_period = pdMS_TO_TICKS(BATTERY_UPDATE_INTERVAL_MS);
    
    // Wait a bit for system to initialize
    vTaskDelay(pdMS_TO_TICKS(2000));
    
    while (1) {
        TickType_t current_time = xTaskGetTickCount();
        
        // Update battery level periodically
        if ((current_time - last_update) >= update_period) {
            last_update = current_time;
            
            // Read battery percentage
            uint8_t battery_pct = battery_get_percentage();
            
            // Log battery level
            ESP_LOGI(TAG, "Battery: %d", battery_pct);
            
            // Send over BLE if connected
            if (ble_is_connected()) {
                ble_send_battery(battery_pct);
            }
        }
        
        // Sleep for most of the period to save CPU
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
}

static void sensor_task(void *pvParameters)
{
    TickType_t last_measurement = 0;
    TickType_t last_ble_update = 0;
    const TickType_t measurement_period = pdMS_TO_TICKS(10);  // 100Hz
    const TickType_t ble_update_period = pdMS_TO_TICKS(50);   // 20Hz

#if BLE_TEST_MODE    
    ESP_LOGI(TAG, "Sensor task started (BLE TEST MODE - dummy data)");
#else
    ESP_LOGI(TAG, "Sensor task started");
#endif

    while (1) {
        TickType_t current_time = xTaskGetTickCount();

        // Take measurement every 10ms (100Hz)
        if ((current_time - last_measurement) >= measurement_period) {
            last_measurement = current_time;

#if BLE_TEST_MODE
            // Generate dummy data for BLE transmission
            generate_dummy_data();
#else
            // Read results from each chip
            for (int pcap_num = PCAP_CHIP_2; pcap_num <= PCAP_CHIP_8; pcap_num++) {
                pcap_read_data((pcap_chip_select_t)pcap_num, &chip_data[pcap_num]);

                // Apply NN-based hysteresis compensation
                if (nn_is_ready()) {
                    nn_compensate_chip(&chip_data[pcap_num]);
                }
            }
#endif
            // Print results to serial
            print_results();
        }

        // Send BLE updates every 50ms (20Hz) if connected
        if (ble_is_connected() && (current_time - last_ble_update) >= ble_update_period) {
            last_ble_update = current_time;

            // Send data from all active chips
            for (int pcap_num = PCAP_CHIP_2; pcap_num <= PCAP_CHIP_8; pcap_num++) {
                ble_send_chip_data(pcap_num, &chip_data[pcap_num]);
            }
        }

        // Delay to allow other tasks to run
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

void app_main(void)
{
    ESP_LOGI(TAG, "========================================");
    ESP_LOGI(TAG, "PCAP04 ESP32C3 Firmware Starting...");
#if BLE_TEST_MODE
    ESP_LOGI(TAG, "*** BLE TEST MODE ENABLED ***");
#endif
    ESP_LOGI(TAG, "========================================");

#if !BLE_TEST_MODE
    bool test_result = false;

    // Initialize PCAP driver (includes SPI and MUX init)
    pcap_driver_init();
    vTaskDelay(pdMS_TO_TICKS(1000));

    // Test communication with each chip
    ESP_LOGI(TAG, "--- Testing Communication ---");
    for (int pcap_num = PCAP_CHIP_2; pcap_num <= PCAP_CHIP_8; pcap_num++) {
        // Block until we validate a successful communication
        test_result = false;
        while (!test_result) {
            test_result = pcap_test_communication((pcap_chip_select_t)pcap_num);
            vTaskDelay(pdMS_TO_TICKS(10));
        }
    }

    // Initialize chips
    ESP_LOGI(TAG, "--- Initializing Chips ---");
    for (int pcap_num = PCAP_CHIP_2; pcap_num <= PCAP_CHIP_8; pcap_num++) {
        pcap_init_chip((pcap_chip_select_t)pcap_num);
        pcap_write_firmware((pcap_chip_select_t)pcap_num, standard_firmware, PCAP_FW_SIZE);
        pcap_write_config((pcap_chip_select_t)pcap_num, standard_config, PCAP_CONFIG_SIZE);
        pcap_start_cdc((pcap_chip_select_t)pcap_num);
    }

    // Wait for first measurement to complete
    ESP_LOGI(TAG, "--- Waiting for measurements to stabilize ---");
    vTaskDelay(pdMS_TO_TICKS(20));

    // Calibrate all chips
    ESP_LOGI(TAG, "--- Calibrating Sensors ---");
    for (int pcap_num = PCAP_CHIP_2; pcap_num <= PCAP_CHIP_8; pcap_num++) {
        pcap_calibrate((pcap_chip_select_t)pcap_num, &chip_data[pcap_num], 10);
    }
#endif

    // Initialize BLE
    ESP_LOGI(TAG, "--- Initializing BLE ---");
    ble_manager_init();

    // Initialize Neural Network (optional - will gracefully fail if no model)
    ESP_LOGI(TAG, "--- Initializing Neural Network ---");

    // if (nn_init()) {
    //     ESP_LOGI(TAG, "Neural network initialized successfully");
    // } else {
    //     ESP_LOGW(TAG, "Neural network initialization failed - using raw values");
    // }

    // Print diagnostics
    print_diagnostics();

    ESP_LOGI(TAG, "Setup complete! Starting measurements...");

    // Create sensor task (high priority for time-critical measurements)
    xTaskCreate(sensor_task, "sensor_task", 4096, NULL, 5, NULL);
    
    // Create battery monitoring task (lower priority, less time-critical)
    // xTaskCreate(battery_task, "battery_task", 1024, NULL, 3, NULL);

    // Main task can now idle
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}